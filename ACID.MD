# 1. ACID

**A 原子性（Atomicity） [ˌædəˈmɪsədi]** 

​     就是把事物分割成像原子一样，表示我们事物需要细微的去控制。比如我给你转钱，里面有我扣钱，你到账。总不能我扣了钱，你没到账这种情况吧。所以就是指转账这个事物， 里面的所有环节哪怕一个出错，都需要事物回滚，就是一切回到之前那样。

**C 一致性（Consistency） [kənˈsɪstənsi]**

​      一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

　　  还是转账来说，假设用户A和用户B两者的钱加起来一共是1000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是1000，这就是事务的一致性。

**I 隔离性（Isolation） [ˌaɪsəˈleɪʃ(ə)n]**

​    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
　　   即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
　   　关于事务的隔离性数据库提供了4种隔离级别，稍后会介绍到。

**D 持久性（Durability）[ˌdjʊərə'bɪləti]**

​    持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。



| Database             | Default isolation Level                 |
| :------------------- | :-------------------------------------- |
| Oracle               | READ_COMMITTED                          |
| MySQL                | REPETABLE_READ                          |
| Microsoft SQL Server | READ_COMMITTED                          |
| PostgreSQL           | READ_COMMITTED                          |
| DB2                  | CURSOR STABILITY (a.k.a READ_COMMITTED) |





# 2. 事务隔离性

**2.1  未提交读(Read uncommitted)。 （写加锁，读不加锁）**
写操作加写锁，读操作不加锁。禁止第一类丢失更新，但是会出现所有其他数据并发问题。

**
**

**2.2 提交读(Read committed)。（写加锁，读加锁）**

写操作加写锁，读操作加读锁。禁止第一类丢失更新和脏读。

就是你已经开始读了数据，然后一个事物开始写，然后写的事物不提交的话，是不能进行读的事物，避免了脏读。



##### 2.3 可重复读(Read repeatable)。（写加锁，读加锁）**

对于读操作加读锁到事务结束，其他事务的更新操作只能等到事务结束之后进行。和提交 读的区别在于，

提交读的读操作是加读锁到本次读操作结束，可重复读的锁粒度更大。禁止两类丢失更新，禁止脏读和不可 重复度，但是可能出现幻读.

一个事物读的时候，我们把两次读看成整体，在读的过程中，不允许写的操作，这样就可以禁止不可重复读。就是两次读操作不允许其他事物。

**这是大部分关系数据库的默认 隔离级别。**





**2.5 序列化(Serializable)。（对表级读 写加锁）**

读操作加表级读锁至事务结束。可以禁止幻读。