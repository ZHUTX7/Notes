---
typora-root-url: ..\Git图库
typora-copy-images-to: ..\Git图库
---

# 1. 简介

**ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能**

2.分布式系统面临的问题

​	2.1网络故障

​				例如：消息延迟 ， 网络不安全 ， 网络不稳定 

​	2.2处理器性能

# **2. 使用场景**

**Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心(提供发布订阅服务)。**

# 3. 具体用法：

​				 ZooKeeper 作为 Dubbo 的注册中心(Dubbo 官方推荐使用 ZooKeeper注册中心)。另外在搭建 solr 集群的时候，我使用 ZooKeeper 作为 solr 集群的管理工具。这时，ZooKeeper 主要提供下面几个功能：1、集群管理：容错、负载均衡。2、配置文件的集中管理3、集群的入口。

我个人觉得在使用 ZooKeeper 的时候，最好是使用 集群版的 ZooKeeper 而不是单机版的。官网给出的架构图就描述的是一个集群版的 ZooKeeper 。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。



# 4. 通信方式

## 	4.1 **通过网络进行信息共享**

##     4.2 通过共享存储



# 5. ZooKeeper特点

- **顺序一致性：** 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。
- **原子性：** 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。
- **单一系统映像 ：** 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。
- **可靠性：** 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。



# 6.1 Zookeeper设计目标

## 	6.1.1简单的数据模型

​		ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。 名称空间由 ZooKeeper 中的数据寄存器组成 - 称为znode，这些类似于文件和目录。 与为存储设计的典型文件系统不同，<u>ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。</u>

## 	6.1.2可构建集群

​		**为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的。** 客户端在使用 ZooKeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个TCP链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。

## 	6.1.3 顺序访问

​		**对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。** **这个编号也叫做时间戳——zxid（Zookeeper Transaction Id）**



## 	6.1.4 高性能

​		**ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）**



# PS

## **为什么最好使用奇数台服务器构成 ZooKeeper 集群？**

所谓的zookeeper容错是指，当宕掉几个zookeeper服务器之后，剩下的个数必须大于宕掉的个数的话整个zookeeper才依然可用。假如我们的集群中有n台zookeeper服务器，那么也就是剩下的服务数必须大于n/2。先说一下结论，2n和2n-1的容忍度是一样的，都是n-1，大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。 比如假如我们有3台，那么最大允许宕掉1台zookeeper服务器，如果我们有4台的的时候也同样只允许宕掉1台。 假如我们有5台，那么最大允许宕掉2台zookeeper服务器，如果我们有6台的的时候也同样只允许宕掉2台。

综上，何必增加那一个不必要的zookeeper呢？



# Znode的不同类型

创建节点的时候需要制定节点类型，不同的节点类型决定了znode的行为方式。

**持久节点和临时节点**

**<u>持久znode</u>**只能通过delete命令删除

***临时znode***是在当创建该节点的客户端崩溃或者关闭了与zookeeper的连接时，这个节点就会被删除。

**<u>持久znode</u>**可以为应用保存一些数据，即使znode的创建者不再属于系统，这些数据也可以保存下来不丢失。

***临时znode***传达了应用某些方面的信息，在创建者的会话有效时这些信息必须有效保存。列如，主从模式中，主节点创建了一个临时的znode，如果主znode消失了，该临时的znode节点仍然存在，那么系统将无法检测到主节点崩溃，因此这个临时的znode需要和主节点一起消失。

一个znode，在以下两种情况会被删除：

1.创建该node的客户端的会话因为超时或者主动关闭而终止时。

2.当某个 客户端主动删除该节点时。

另外，临时节点是不允许拥有子节点的。

有序节点

一个有序节点在创建的时候会在路径后面追加一个单调递增的整数，比如task/task_1

所以节点类型被分为持久的有序，临时的有序，持久的，临时的。



由于轮询



## 3.3 